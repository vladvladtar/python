# на вход подается последовательность чисел через пробел, а также запрашивается у пользователя любое число
ll = input('введите последовательность целых чисел через пробел, затем нажмите "ENTER" : ')

import typing
A: list[typing.Union[str, int]] = list(map(str, ll.split()))  # Преобразование введённой последовательности в строку

for i in range(len(A)):  # выполняется проверка соответствия указанному в условии ввода данных - число/не число.
    try:
        A[i] = int(A[i])
    except ValueError:
        print('неверный формат данных, запустите скрипт сначала.')
        exit()

LL = list(map(int, ll.split()))  # Преобразование введённой последовательности в список
# запрос дополнительного числа пользователя
user = (input(' Веедите своё дополнительное целое число, затем нажмите "ENTER" : '))
try:  # выполняется проверка соответствия указанному в условии ввода данных - число/не число.
    user = int(user)
except ValueError:
    print('неверный формат данных, запустите скрипт сначала.')
    exit()
LL.append(user)  # добавление в список дополнительного числа, в конец списка
ui = (len(LL) - 1)  # кол-во позиций списка
user_index = ui  # запомним индекс позиции введенного пользователем числа
print('Полученный от Вас список : ', LL)  # печать полученного списка

print('Индекс Вашего числа : ', user_index)

# Сортировка списка по возрастанию элементов в нем
for i in range(1, len(LL)):  # выбираю алгоритм сортировки вставками
    x = LL[i]
    idx = i
    while idx > 0 and LL[idx - 1] > x:
        if user_index == idx:  # изменяем индекс позиции введенного пользователем числа при сортировке
            user_index = (idx - 1)
        LL[idx] = LL[idx - 1]
        idx -= 1
    LL[idx] = x

print('Сортированный список : ', LL)  # печать отсортированного списка

print('Индекс позиции Вашего числа : ',
      user_index)  # печать индекса позиции веденного пользователем числа, вычисленного при сортировка


def binary_search(LL, user, left, right):  # установка позиции элемента алгоритмом двоичного поиска
    if left > right:  # если левая граница превысила правую,
        return False  # значит элемент отсутствует

    middle = (right + left) // 2  # находимо середину
    if LL[middle] == user:  # если элемент в середине,
        return middle  # возвращаем этот индекс
    elif user < LL[middle]:  # если элемент меньше элемента в середине
        # рекурсивно ищем в левой половине
        return binary_search(LL, user, left, middle - 1)
    else:  # иначе в правой
        return binary_search(LL, user, middle + 1, right)


user_index = (binary_search(LL, user, 0, ui))
print('Индекс позиции Вашего числа : ',
      user_index)  # печать индекса веденного пользователем числа, вычисленного при выполнении алгоритма

# Помните, что у вас есть числа, которые могут не соответствовать заданному условию.
# В этом случае необходимо вывести соответствующее сообщение (это может быть наименьшее или наибольшее число)
less_user_index = (user_index - 1)
if less_user_index < 0:
    print('Меньшего числа, чем Ваше, в списке нет')
else:
    print('Индекс позиции элемента меньше Вашего числа : ',
          less_user_index)  # печать индекса позиции меньшего чем введенное пользователем число

more_user_index = (user_index + 1)
if more_user_index > ui:
    print('Большего числа, чем Ваше, в списке нет')
else:
    print('Индекс позиции элемента больше Вашего числа : ',
          more_user_index)  # печать индекса позиции меньшего чем введенное пользователем число


