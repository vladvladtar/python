# на вход подается последовательность чисел через пробел, а также запрашивается у пользователя любое число
ll = input('введите последовательность целых чисел через пробел : ')
A = list(map(str,ll.split()))#Преобразование введённой последовательности в строку

for i in range(len(A)):#выполняется проверка соответствия указанному в условии ввода данных - число/не число.
    try:
        A[i] = int(A[i])
    except ValueError:
        print ('неверный формат данных, запустите скрипт сначала.')
        exit()

LL = list(map(int,ll.split()))#Преобразование введённой последовательности в список

user = (input (' Веедите своё дополнительное целое число : '))#запрос дополнительного числа пользователя
try:#выполняется проверка соответствия указанному в условии ввода данных - число/не число.
    user = int(user)
except ValueError:
    print('неверный формат данных, запустите скрипт сначала.')
    exit()
LL.append(user)#добавление в список дополнительного числа, в конец списка
ui = (len(LL)- 1)#кол-во позиций списка
user_index = (ui)#запомним индекс позиции введенного пользователем числа
print('Полученный от Вас список : ', (LL))# печать полученного списка

print ('Индекс Вашего числа : ', (user_index))

#Сортировка списка по возрастанию элементов в нем
for i in range(1, len(LL)):#выбираю алгоритм сортировки вставками
    x = LL[i]
    idx = i
    while idx > 0 and LL[idx-1] > x:
        if idx == (user_index):#изменяем индекс позиции введенного пользователем числа при сортировке
            user_index = (idx-1)
        LL[idx] = LL[idx-1]
        idx -= 1
    LL[idx] = x

print('Сортированный список : ', (LL)) # печать отсортированного списка

print ('Индекс позиции Вашего числа : ', (user_index)) #печать индекса позиции веденного пользователем числа, вычисленного при сортировка

def binary_search(LL, user, left, right): # установка позиции элемента алгоритмом двоичного поиска
    if left > right:  # если левая граница превысила правую,
        return False  # значит элемент отсутствует

    middle = (right + left) // 2  # находимо середину
    if LL[middle] == user:  # если элемент в середине,
        return middle  # возвращаем этот индекс
    elif user < LL[middle]:  # если элемент меньше элемента в середине
        # рекурсивно ищем в левой половине
        return binary_search(LL, user, left, middle - 1)
    else:  # иначе в правой
        return binary_search(LL, user, middle + 1, right)
user_index = (binary_search(LL, user, 0, ui))
print('Индекс позиции Вашего числа : ', (user_index)) #печать индекса веденного пользователем числа, вычисленного при выполнении алгоритма

#Помните, что у вас есть числа, которые могут не соответствовать заданному условию. В этом случае необходимо вывести соответствующее сообщение (это может быть наименьшее или наибольшее число)
less_user_index = ((user_index) - 1)
if less_user_index < 0:
    print ('Меньшего числа, чем Ваше, в списке нет')
else:
    print('Индекс позиции элемента меньше Вашего числа : ', (less_user_index)) #печать индекса позиции меньшего чем введенное пользователем число

more_user_index = ((user_index) + 1)
if more_user_index > (ui):
    print('Большего числа, чем Ваше, в списке нет')
else:
    print('Индекс позиции элемента больше Вашего числа : ', (more_user_index))  #печать индекса позиции меньшего чем введенное пользователем число



